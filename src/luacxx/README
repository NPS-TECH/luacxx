=head1 NAME

luacxx - C++11 API for creating Lua bindings

=head1 SYNOPSIS

    // Create a new Lua environment to play with.
    auto env = lua::create();

    // Introduce a global into Lua
    env["foo"] = "No time";

    // Run some Lua code directly
    lua::run_string("assert(foo == 'No time')");

    // Retrieve a global
    auto value = env["foo"].get<std::string>();
    assert(value == "No time");

=head1 DESCRIPTION

Luacxx is a C++ library that helps you write Lua bindings for C++ and C code.
It also contains complete bindings for several major C and C++ libraries.

B<Luacxx plays well with others.> Luacxx does not try to cover up Lua's C API
or its stack-based model. In fact, Luacxx and Lua C API's can and must be
mixed freely, and Luacxx works transparently over Lua's stack, so you can work
using either one. There is absolutely no harm in mixing the two together.

B<Luacxx is fast>. A binding's overhead of calling into C and converting
arguments can be significant for simple methods. Luacxx has been built
specifically for efficiency, so it has avoided much of the overhead
that plagues other bindings (and older versions of Luacxx!).

Luacxx's overhead is around that of an extra function call, which means that a
C++ binding will be faster than equivalent Lua code for all but the most
trivial of cases. For instance, this math-intensive benchmark has the
QQuaternion binding performing ~150% faster than an API-indentical quaternion
written in Lua:

    quat = QQuaternion:new(2, 3, 7, 5);
    for i=1, MAX do
        -- Do some CPU-intensive matrix math, as well as creating a temporary.
        quat = quat * QQuaternion:new(2, 2, 2, 2);
        quat:normalize();
    end

    // My numbers
    Benchmark Runs: 10000
    C++:      0.824ms ( 1.00 relative to C++)
    Lua:     21.514ms (26.10 relative to C++)
    Luacxx: 13.579ms (16.47 relative to C++)

B<Luacxx is frugal>. Luacxx takes advantage of C++'s memory efficiency.
Objects pushed on the Lua stack are instantiated directly on new Lua userdata,
and with only 4 bytes of Luacxx-specific metadata appended to the end.
lua_touserdata works out-of-the-box, and the returned value can be cast
directly to the intended C++ type.

B<Luacxx is open-ended>. Much of Luacxx is built using class templates. This
allows you to add new support for your own types without needing to recompile
Luacxx. Once a new template specialization for your type is found, all of
Luacxx's APIs will be able to use it.

B<Luacxx is comprehensive>. Luacxx includes bindings for over 150 Qt classes,
as well as automatic introspection support for QObjects. It also has
preliminary support for Gtk's introspection system, allowing any project with
GObject introspection support to work with Luacxx.

B<Luacxx is not a generator>. Luacxx doesn't write header files or extra
boilerplate. Everything can be done using just a C++11 compiler.

=head2 INTENDED USAGE

Luacxx is built to make writing bindings easy. It's all too common that you
have to choose between a terrible API that's fast or a good API that's slow and
bloated, so I wanted to provide an alternative that doesn't get in your way
while still giving you sufficient power to get things done.

=head2 EXTENDED OVERVIEW

This library is designed to work in tandem with Lua's existing C API, so it
does not provide a complete facade. On the contrary, I find Lua's C API to be
amazingly well-designed, so I've tried to ensure that Luacxx can be intermixed
freely with Lua's C API. In fact, most of the Lua C API has no analog in
Luacxx - I just use the original, like in the following example:

    // Add all arguments
    int add_several(lua_State* const state)
    {
        // Get each argument
        int sum = 0;
        for (int i = 1; i <= lua_gettop(state); ++i) {
            sum += lua::get<int>(state, i);
        }

        // Return the value
        lua::push(state, sum);
        lua_replace(state, 1);
        return 1;
    }

That being said, there are several places where Luacxx greatly simplify common
tasks. For instance, Lua has a number of lua_push* functions that can be
replaced with Luacxx's lua::push template and appropriate specializations. You
can extend this specialization with your own types, and Luacxx's other
features will immediately support them.

C++11 also adds support for variadic templates, which can be used to provide a
way to push a function of any arity into Lua without needing to write the
marshalling code yourself or running a preprocessor:

    // Standard C API is, of course, supported
    int create_foo(lua_State* const);
    lua::push(state, create_foo);

    // Fundamental types work, too
    int sum(int a, int b);
    lua::push(state, sum);

    // As do pointers to userdata and conversions to C++ strings.
    void changeTitle(QWindow* window, const std::string& title);
    lua::push(state, changeTitle);

    // Even lambdas work too, with a bit of help
    lua::push_function< int(int, int) >(state, [](int first, int second) {
        return first + second;
    });

=head1 STYLE

STL conventions are used for naming and case, though not slavishly, to
infer that a template-heavy C++ dialect is used. However, adherance to Lua's
conventions is preferred over that of C++.

=head1 SEE ALSO

Lua 5.2 - http://www.lua.org/manual/5.2/manual.html

    Lua is an extension programming language designed to support general
    procedural programming with data description facilities.

Qt - http://qt-project.org/doc/qt-5/modules-cpp.html

    Qt is a cross-platform application and UI framework for developers.

=head1 ALTERNATIVES

LuaJIT - http://luajit.org/index.html

    LuaJIT is a Just-In-Time Compiler (JIT) for the Lua programming language.

tolua++ - http://www.codenix.com/~tolua/

    tolua++ is an extended version of tolua, a tool to integrate C/C++ code
    with Lua.

tolua - http://www.tecgraf.puc-rio.br/~celes/tolua/

    tolua is a tool that greatly simplifies the integration of C/C++ code with Lua.
    Based on a cleaned header file, tolua automatically generates the binding code
    to access C/C++ features from Lua.

Luabind - http://www.rasterbar.com/products/luabind.html

    Luabind is a library that helps you create bindings between C++ and Lua. It
    has the ability to expose functions and classes, written in C++, to Lua. It
    will also supply the functionality to define classes in lua and let them
    derive from other lua classes or C++ classes. Lua classes can override
    virtual functions from their C++ baseclasses.

lqt - https://github.com/mkottman/lqt

    lqt is a Lua binding to the Qt framework. It is an automated binding
    generated from the Qt headers, and covers almost all classes and methods
    from supported Qt modules.

QtLua - http://www.nongnu.org/libqtlua/

    The QtLua library aims to make Qt4/Qt5 applications scriptable using the
    Lua scripting language. It is an alternative to the QtScript module.

LGI - https://github.com/pavouk/lgi

    LGI is gobject-introspection based dynamic Lua binding to GObject based
    libraries. It allows using GObject-based libraries directly from Lua.

=head1 LICENSE

Source files under luacxx/* use the MIT license.
