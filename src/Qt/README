=head1 NAME

Lua-cxx Qt support

=head1 SYNOPSIS

    #include <luacxx/stack.hpp>
    #include <luacxx/type/standard.hpp>
    #include <luacxx/type/function.hpp>

    #include <QWindow>

    int QWindow_new(lua_State* const state)
    {
        if (lua_gettop(state) > 1) {
            auto parent = lua::get<QObject*>(state, 2);
            lua_settop(state, 0);

            if (parent) {
                if (parent->inherits("QWindow")) {
                    lua::make<QWindow>(state, static_cast<QWindow*>(parent));
                } else {
                    lua::make<QWindow>(state, static_cast<QScreen*>(parent));
                }
                return 1;
            }

            // Otherwise, fall through
        }

        // Create a QWindow within Lua
        lua::make<QWindow>(state, static_cast<QWindow*>(nullptr));
        return 1;
    }

    int luaopen_QWindow(lua_State* const state)
    {
        lua::thread env(state);

        env["QWindow"] = lua::value::table;
        env["QWindow"]["new"] = QWindow_new;

        return 1;
    }

    // Within Lua

    require "QWindow";

    local window = QWindow:new();
    window.width = 300;
    window.height = 300;
    window.title = "Hello, world";
    window:show();

=head1 DESCRIPTION

This subdirectory provides full support for Qt QObject introspection
system. This allows all objects that derive from QObject to automatically
expose their properties, signals, and slots, as well as any methods
prefixed with Q_INVOKABLE. These methods can have any signature as long
as each type is supported by this library and your lua::Push<> structs.

This subdirectory also contains prebuilt bindings for many Qt classes.  Each
class adheres to its documented Qt API where possible, including naming
conventions. This allows the programmer to use Qt's API documentation directly,
rather than needing to relearn this project's dialect.

=head1 SUPPORTED CLASSES

All exported symbols from the QtCore and QtGui modules are to be supported. There
are some areas where exact support is not possible or desired.

When possible, the function signature should be matched exactly, like so:

    mt["brush"] = &QPainter::brush;

Overloaded methods cannot be matched exactly, as they would be ambiguous. Therefore,
a separate method should be created to determine the correct method:

    int QPainter_fillRect(lua::state* const state)
    {
        auto painter = lua::get<QPainter*>(state, 1);

        // Determine the method to call
        switch (lua_gettop(state)) {
        case 2:
            painter->fillRect(
                lua::get<int>(state, 2),
                lua::get<int>(state, 3),
                lua::get<int>(state, 4),
                lua::get<int>(state, 5),
            );
            break;
        default:
        }
    }

    mt["fillRect"] = QPainter_fillRect;

Some Qt methods use signatures like (int*, int*, int*, int*) to return multiple
values.  These simply return those values on the stack.

In the rare case that a name collision occurs, a new name should be made. For
instance, "end" is a keyword in Lua, so it cannot be natively used as a
function name.

Extensions to the Qt API should only be done when their benefit outweighs their
cost to maintain. For the most part, the Qt API should be ported directly
without any modification. For instnace, Lua-cxx should perform only essential
error-checking on called methods, but there is no guarantee that a call won't
corrupt memory, segfault, or do anything that couldn't happen in C++.

These constraints may seem overly strict, but having them and abiding by them
simplifies the task of writing a binding. It also makes it very easy for anyone
to maintain. Classes can be constructed in Lua to provide a better facade over
the underlying library.

=over 4

=item B<QtCore C++ classes> - https://qt-project.org/doc/qt-5/qtcore-module.html

=item B<QtGui C++ classes> - https://qt-project.org/doc/qt-5/qtgui-module.html

=back
